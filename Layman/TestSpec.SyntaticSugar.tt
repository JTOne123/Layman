<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="EnvDTE" #>
<#@ import Namespace="EnvDTE" #>
<#@ import Namespace="System.Linq" #>
<#@ import Namespace="System.Collections.Generic" #>// ~ Generated by TestSpec.SyntaticSugar.tt
<#
    string[] aliases = { "Then", "That", "And" };

    var hostServiceProvider = (IServiceProvider)Host;
    var dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    
    var containingProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
    Project project = containingProjectItem.ContainingProject;

    var testSpecItem = project.ProjectItems.Item("TestSpec.cs");
    if (testSpecItem != null)
    {
        var codeModel = testSpecItem.FileCodeModel;
        CodeClass theClass = null;

        var namespaceElement = codeModel.CodeElements.Cast<CodeElement>().FirstOrDefault(e => 
                                e.Kind == vsCMElement.vsCMElementNamespace &&
                                e.Children != null &&
                                null != (theClass = (CodeClass)e.Children.Cast<CodeElement>().FirstOrDefault(c => c.Kind == vsCMElement.vsCMElementClass && c.Name == "TestSpec")));
        if (namespaceElement == null || theClass.Children == null) 
        {
            return string.Empty;
        }

        var usings = from c in codeModel.CodeElements.Cast<CodeElement>()
                     where c.Kind == vsCMElement.vsCMElementImportStmt
                     select c;
        foreach (CodeElement u in usings)
        {
            WriteLine(GetText(u, vsCMPart.vsCMPartWholeWithAttributes));
        } #>

namespace <#= namespaceElement.Name #>
{
    partial class <#= theClass.Name #>
    {
<#
        // By now, we know that TestSpec class was found inside the namespaceElement
        var functions = from CodeElement c in theClass.Children
                        where c.Kind == vsCMElement.vsCMElementFunction
                        select c;
        foreach (CodeFunction f in functions)
        {
            if ("It" == f.Name && IsAsync(f))
            {
                for (int i = aliases.Length - 1; i >= 0; i--)
                {
#>
        protected async Task <#= aliases[i] #>(<#= GetParameters(f) #>)
        {
            await It(<#= GetCallingParamList(f) #>);
        }

<#
                }
            }
            else if ("It" == f.Name)
            {
                for (int i = aliases.Length - 1; i >= 0; i--)
                {
#>
        protected void <#= aliases[i] #>(<#= GetParameters(f) #>)
        {
            It(<#= GetCallingParamList(f) #>);
        }

<#
                }
            }
        }
    }
#>
    }
}
<#+

private bool IsAsync(CodeFunction function)
{
    return function.Type.AsString == "System.Threading.Tasks.Task";
}

private string GetCallingParamList(CodeFunction function)
{
    var b = new System.Text.StringBuilder();
    foreach (CodeParameter p in function.Parameters)
    {
        b.Append(p.Name);
        b.Append(", ");
    }
    if (b.Length > 0)
    {
        b.Remove(b.Length - 2, 2);
    }
    return b.ToString();
}

private string GetParameters(CodeFunction function)
{
    var paramString = new System.Text.StringBuilder();
    foreach (CodeParameter p in function.Parameters)
    {
        paramString.Append(GetText((CodeElement)p, vsCMPart.vsCMPartWholeWithAttributes));
        paramString.Append(", ");
    }
    
    if (paramString.Length > 0)
    {
        paramString.Remove(paramString.Length - 2, 2);
    }

    return paramString.ToString();
}

private string GetText(CodeElement element, vsCMPart part)
{
    TextPoint start = element.GetStartPoint(part);
    TextPoint finish = element.GetEndPoint(part);
    return start.CreateEditPoint().GetText(finish);
}

#>